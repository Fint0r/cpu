-- Generated by Fintor Jozsef's script.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
library UNISIM;
use UNISIM.VCOMPONENTS.ALL;

entity tb_pc_and_bram is
end tb_pc_and_bram;

architecture tb of tb_pc_and_bram is
	component a_register
     Port ( a_in : in STD_LOGIC_VECTOR (7 downto 0);
           load : in STD_LOGIC;
           clock : in STD_LOGIC;
           a_out : inout STD_LOGIC_VECTOR (7 downto 0));
     end component;
	
	component pc_wrapper
		port (
			CE_0	:	in STD_LOGIC;
			CLK_0	:	in STD_LOGIC;
			LOAD_0	:	in STD_LOGIC;
			L_0	:	in STD_LOGIC_VECTOR ( 15 downto 0 );
			Q_0	:	out STD_LOGIC_VECTOR ( 15 downto 0 ));
	end component;
    
    component bram_wrapper
            Port (  clock: IN STD_LOGIC;
            addr_in: IN STD_LOGIC_VECTOR(15 DOWNTO 0);
            data_out: OUT STD_LOGIC_VECTOR(15 DOWNTO 0));
    end component;
    
    component CU
		    Port ( func : in STD_LOGIC_VECTOR (3 downto 0);
           target : in STD_LOGIC_VECTOR (11 downto 0);
           clock : in STD_LOGIC;
           neg : in STD_LOGIC;
           a_reg_load : out STD_LOGIC;
           b_reg_load : out STD_LOGIC;
           a_reg_data: out STD_LOGIC_VECTOR (7 downto 0);
           b_reg_data: out STD_LOGIC_VECTOR (7 downto 0);
           
           pc_load : out STD_LOGIC;
           pc_ce : out STD_LOGIC;
           pc_load_data : out STD_LOGIC_VECTOR (15 downto 0);
           
           alu_addr : out STD_LOGIC_VECTOR (3 downto 0);
           
           BRAM_PORTA_0_addr	:	in STD_LOGIC_VECTOR ( 3 downto 0 );
           BRAM_PORTA_0_din	:	in STD_LOGIC_VECTOR ( 7 downto 0 );
           BRAM_PORTA_0_dout	:	out STD_LOGIC_VECTOR ( 7 downto 0 );
		   BRAM_PORTA_0_en	:	in STD_LOGIC;
		   BRAM_PORTA_0_we	:	in STD_LOGIC_VECTOR ( 0 to 0 ));
	end component;
	
	
	 signal neg	: STD_LOGIC;
	 signal a_reg_load	: STD_LOGIC;
	 signal b_reg_load	: STD_LOGIC;
	 signal a_reg_data	: STD_LOGIC_VECTOR (7 downto 0);
	 signal b_reg_data	: STD_LOGIC_VECTOR (7 downto 0);
	 signal alu_addr	: STD_LOGIC_VECTOR (3 downto 0);
	 signal BRAM_PORTA_0_addr	: STD_LOGIC_VECTOR ( 3 downto 0 );
	 signal BRAM_PORTA_0_din	: STD_LOGIC_VECTOR ( 7 downto 0 );
	 signal BRAM_PORTA_0_dout	: STD_LOGIC_VECTOR ( 7 downto 0 );
	 signal BRAM_PORTA_0_en	: STD_LOGIC;
	 signal BRAM_PORTA_0_we	: STD_LOGIC_VECTOR ( 0 to 0 );
    
    
	 signal CLK_0	: STD_LOGIC;
	 signal LOAD_0	: STD_LOGIC;
	 signal L_0	: STD_LOGIC_VECTOR ( 15 downto 0 );
     
     
     signal a_reg_out : STD_LOGIC_VECTOR (7 downto 0);
        
        
    signal addr: STD_LOGIC_VECTOR(15 DOWNTO 0);
    signal data_out: STD_LOGIC_VECTOR(15 DOWNTO 0);   
    
    
    signal pc_ce_check: STD_LOGIC; 
    
begin
    
	dut : pc_wrapper
	port map (
			CE_0	 => pc_ce_check,
			CLK_0	 => CLK_0,
			LOAD_0	 => LOAD_0,
			L_0	 => L_0,
			Q_0	 => addr);
    
    dut2 : bram_wrapper
    port map (clock    => CLK_0,
              addr_in  => addr,
              data_out => data_out);

		dut3 : CU
	port map (
			func	 => data_out(15 downto 12),
			target	 => data_out(11 downto 0),
			clock	 => CLK_0,
			neg	 => neg,
			a_reg_load	 => a_reg_load,
			b_reg_load	 => b_reg_load,
			a_reg_data	 => a_reg_data,
			b_reg_data	 => b_reg_data,
			pc_load	 => LOAD_0,
			pc_ce => pc_ce_check,
			pc_load_data	 => L_0,
			alu_addr	 => alu_addr,
			BRAM_PORTA_0_addr	 => BRAM_PORTA_0_addr,
			BRAM_PORTA_0_din	 => BRAM_PORTA_0_din,
			BRAM_PORTA_0_dout	 => BRAM_PORTA_0_dout,
			BRAM_PORTA_0_en	 => BRAM_PORTA_0_en,
			BRAM_PORTA_0_we	 => BRAM_PORTA_0_we);
	
	dut4 : a_register
	port map (
	   a_in => a_reg_data,
	   load => a_reg_load,
	   clock => CLK_0,
	   a_out => a_reg_out
	);
            
	stimuli : process
      
	begin
	    
            
            
		-- Write initialization here.
        wait for 10ns;
        CLK_0 <= '0';
		-- Write stimuli here.

		-- Write stimuli here.


		wait;
	end process;

end tb;